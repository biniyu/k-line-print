// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: toptrader.proto

#ifndef PROTOBUF_toptrader_2eproto__INCLUDED
#define PROTOBUF_toptrader_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace toptraer {
namespace oscar {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_toptrader_2eproto();
void protobuf_AssignDesc_toptrader_2eproto();
void protobuf_ShutdownFile_toptrader_2eproto();

class GenHeader;
class LoginCmd;
class LoginAck;
class AccountQuery;
class AccountAck;
class AccountAck_AccountInfo;
class AccountAck_OrderInfo;
class AccountAck_PositionInfo;

// ===================================================================

class GenHeader : public ::google::protobuf::Message {
 public:
  GenHeader();
  virtual ~GenHeader();

  GenHeader(const GenHeader& from);

  inline GenHeader& operator=(const GenHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenHeader& default_instance();

  void Swap(GenHeader* other);

  // implements Message ----------------------------------------------

  GenHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenHeader& from);
  void MergeFrom(const GenHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 magic = 1;
  inline bool has_magic() const;
  inline void clear_magic();
  static const int kMagicFieldNumber = 1;
  inline ::google::protobuf::uint32 magic() const;
  inline void set_magic(::google::protobuf::uint32 value);

  // required uint32 len = 2;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 2;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // required uint32 tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline ::google::protobuf::uint32 tag() const;
  inline void set_tag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:toptraer.oscar.GenHeader)
 private:
  inline void set_has_magic();
  inline void clear_has_magic();
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 magic_;
  ::google::protobuf::uint32 len_;
  ::google::protobuf::uint32 tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_toptrader_2eproto();
  friend void protobuf_AssignDesc_toptrader_2eproto();
  friend void protobuf_ShutdownFile_toptrader_2eproto();

  void InitAsDefaultInstance();
  static GenHeader* default_instance_;
};
// -------------------------------------------------------------------

class LoginCmd : public ::google::protobuf::Message {
 public:
  LoginCmd();
  virtual ~LoginCmd();

  LoginCmd(const LoginCmd& from);

  inline LoginCmd& operator=(const LoginCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginCmd& default_instance();

  void Swap(LoginCmd* other);

  // implements Message ----------------------------------------------

  LoginCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginCmd& from);
  void MergeFrom(const LoginCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:toptraer.oscar.LoginCmd)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_toptrader_2eproto();
  friend void protobuf_AssignDesc_toptrader_2eproto();
  friend void protobuf_ShutdownFile_toptrader_2eproto();

  void InitAsDefaultInstance();
  static LoginCmd* default_instance_;
};
// -------------------------------------------------------------------

class LoginAck : public ::google::protobuf::Message {
 public:
  LoginAck();
  virtual ~LoginAck();

  LoginAck(const LoginAck& from);

  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginAck& default_instance();

  void Swap(LoginAck* other);

  // implements Message ----------------------------------------------

  LoginAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginAck& from);
  void MergeFrom(const LoginAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // optional string errcode = 2;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 2;
  inline const ::std::string& errcode() const;
  inline void set_errcode(const ::std::string& value);
  inline void set_errcode(const char* value);
  inline void set_errcode(const char* value, size_t size);
  inline ::std::string* mutable_errcode();
  inline ::std::string* release_errcode();
  inline void set_allocated_errcode(::std::string* errcode);

  // @@protoc_insertion_point(class_scope:toptraer.oscar.LoginAck)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errcode();
  inline void clear_has_errcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* errcode_;
  bool success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_toptrader_2eproto();
  friend void protobuf_AssignDesc_toptrader_2eproto();
  friend void protobuf_ShutdownFile_toptrader_2eproto();

  void InitAsDefaultInstance();
  static LoginAck* default_instance_;
};
// -------------------------------------------------------------------

class AccountQuery : public ::google::protobuf::Message {
 public:
  AccountQuery();
  virtual ~AccountQuery();

  AccountQuery(const AccountQuery& from);

  inline AccountQuery& operator=(const AccountQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountQuery& default_instance();

  void Swap(AccountQuery* other);

  // implements Message ----------------------------------------------

  AccountQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountQuery& from);
  void MergeFrom(const AccountQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:toptraer.oscar.AccountQuery)
 private:
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_toptrader_2eproto();
  friend void protobuf_AssignDesc_toptrader_2eproto();
  friend void protobuf_ShutdownFile_toptrader_2eproto();

  void InitAsDefaultInstance();
  static AccountQuery* default_instance_;
};
// -------------------------------------------------------------------

class AccountAck_AccountInfo : public ::google::protobuf::Message {
 public:
  AccountAck_AccountInfo();
  virtual ~AccountAck_AccountInfo();

  AccountAck_AccountInfo(const AccountAck_AccountInfo& from);

  inline AccountAck_AccountInfo& operator=(const AccountAck_AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountAck_AccountInfo& default_instance();

  void Swap(AccountAck_AccountInfo* other);

  // implements Message ----------------------------------------------

  AccountAck_AccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountAck_AccountInfo& from);
  void MergeFrom(const AccountAck_AccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required float balance = 2;
  inline bool has_balance() const;
  inline void clear_balance();
  static const int kBalanceFieldNumber = 2;
  inline float balance() const;
  inline void set_balance(float value);

  // required float available = 3;
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 3;
  inline float available() const;
  inline void set_available(float value);

  // optional float lastbalance = 4;
  inline bool has_lastbalance() const;
  inline void clear_lastbalance();
  static const int kLastbalanceFieldNumber = 4;
  inline float lastbalance() const;
  inline void set_lastbalance(float value);

  // optional float buyfreeze = 5;
  inline bool has_buyfreeze() const;
  inline void clear_buyfreeze();
  static const int kBuyfreezeFieldNumber = 5;
  inline float buyfreeze() const;
  inline void set_buyfreeze(float value);

  // optional float sellfreeze = 6;
  inline bool has_sellfreeze() const;
  inline void clear_sellfreeze();
  static const int kSellfreezeFieldNumber = 6;
  inline float sellfreeze() const;
  inline void set_sellfreeze(float value);

  // optional float buymargin = 7;
  inline bool has_buymargin() const;
  inline void clear_buymargin();
  static const int kBuymarginFieldNumber = 7;
  inline float buymargin() const;
  inline void set_buymargin(float value);

  // optional float sellmargin = 8;
  inline bool has_sellmargin() const;
  inline void clear_sellmargin();
  static const int kSellmarginFieldNumber = 8;
  inline float sellmargin() const;
  inline void set_sellmargin(float value);

  // optional float settleprofit = 9;
  inline bool has_settleprofit() const;
  inline void clear_settleprofit();
  static const int kSettleprofitFieldNumber = 9;
  inline float settleprofit() const;
  inline void set_settleprofit(float value);

  // optional float fee = 10;
  inline bool has_fee() const;
  inline void clear_fee();
  static const int kFeeFieldNumber = 10;
  inline float fee() const;
  inline void set_fee(float value);

  // @@protoc_insertion_point(class_scope:toptraer.oscar.AccountAck.AccountInfo)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_balance();
  inline void clear_has_balance();
  inline void set_has_available();
  inline void clear_has_available();
  inline void set_has_lastbalance();
  inline void clear_has_lastbalance();
  inline void set_has_buyfreeze();
  inline void clear_has_buyfreeze();
  inline void set_has_sellfreeze();
  inline void clear_has_sellfreeze();
  inline void set_has_buymargin();
  inline void clear_has_buymargin();
  inline void set_has_sellmargin();
  inline void clear_has_sellmargin();
  inline void set_has_settleprofit();
  inline void clear_has_settleprofit();
  inline void set_has_fee();
  inline void clear_has_fee();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  float balance_;
  float available_;
  float lastbalance_;
  float buyfreeze_;
  float sellfreeze_;
  float buymargin_;
  float sellmargin_;
  float settleprofit_;
  float fee_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_toptrader_2eproto();
  friend void protobuf_AssignDesc_toptrader_2eproto();
  friend void protobuf_ShutdownFile_toptrader_2eproto();

  void InitAsDefaultInstance();
  static AccountAck_AccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class AccountAck_OrderInfo : public ::google::protobuf::Message {
 public:
  AccountAck_OrderInfo();
  virtual ~AccountAck_OrderInfo();

  AccountAck_OrderInfo(const AccountAck_OrderInfo& from);

  inline AccountAck_OrderInfo& operator=(const AccountAck_OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountAck_OrderInfo& default_instance();

  void Swap(AccountAck_OrderInfo* other);

  // implements Message ----------------------------------------------

  AccountAck_OrderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountAck_OrderInfo& from);
  void MergeFrom(const AccountAck_OrderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 orderid = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderidFieldNumber = 1;
  inline ::google::protobuf::uint32 orderid() const;
  inline void set_orderid(::google::protobuf::uint32 value);

  // required string code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // required string status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // required bool buy = 4;
  inline bool has_buy() const;
  inline void clear_buy();
  static const int kBuyFieldNumber = 4;
  inline bool buy() const;
  inline void set_buy(bool value);

  // required bool open = 5;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 5;
  inline bool open() const;
  inline void set_open(bool value);

  // required uint32 commissionslot = 6;
  inline bool has_commissionslot() const;
  inline void clear_commissionslot();
  static const int kCommissionslotFieldNumber = 6;
  inline ::google::protobuf::uint32 commissionslot() const;
  inline void set_commissionslot(::google::protobuf::uint32 value);

  // required float commissionprice = 7;
  inline bool has_commissionprice() const;
  inline void clear_commissionprice();
  static const int kCommissionpriceFieldNumber = 7;
  inline float commissionprice() const;
  inline void set_commissionprice(float value);

  // required uint32 settleslot = 8;
  inline bool has_settleslot() const;
  inline void clear_settleslot();
  static const int kSettleslotFieldNumber = 8;
  inline ::google::protobuf::uint32 settleslot() const;
  inline void set_settleslot(::google::protobuf::uint32 value);

  // required float settleprice = 9;
  inline bool has_settleprice() const;
  inline void clear_settleprice();
  static const int kSettlepriceFieldNumber = 9;
  inline float settleprice() const;
  inline void set_settleprice(float value);

  // required uint32 unsettleslot = 10;
  inline bool has_unsettleslot() const;
  inline void clear_unsettleslot();
  static const int kUnsettleslotFieldNumber = 10;
  inline ::google::protobuf::uint32 unsettleslot() const;
  inline void set_unsettleslot(::google::protobuf::uint32 value);

  // required string commissiontime = 11;
  inline bool has_commissiontime() const;
  inline void clear_commissiontime();
  static const int kCommissiontimeFieldNumber = 11;
  inline const ::std::string& commissiontime() const;
  inline void set_commissiontime(const ::std::string& value);
  inline void set_commissiontime(const char* value);
  inline void set_commissiontime(const char* value, size_t size);
  inline ::std::string* mutable_commissiontime();
  inline ::std::string* release_commissiontime();
  inline void set_allocated_commissiontime(::std::string* commissiontime);

  // required string declaretime = 12;
  inline bool has_declaretime() const;
  inline void clear_declaretime();
  static const int kDeclaretimeFieldNumber = 12;
  inline const ::std::string& declaretime() const;
  inline void set_declaretime(const ::std::string& value);
  inline void set_declaretime(const char* value);
  inline void set_declaretime(const char* value, size_t size);
  inline ::std::string* mutable_declaretime();
  inline ::std::string* release_declaretime();
  inline void set_allocated_declaretime(::std::string* declaretime);

  // required string canceltime = 13;
  inline bool has_canceltime() const;
  inline void clear_canceltime();
  static const int kCanceltimeFieldNumber = 13;
  inline const ::std::string& canceltime() const;
  inline void set_canceltime(const ::std::string& value);
  inline void set_canceltime(const char* value);
  inline void set_canceltime(const char* value, size_t size);
  inline ::std::string* mutable_canceltime();
  inline ::std::string* release_canceltime();
  inline void set_allocated_canceltime(::std::string* canceltime);

  // @@protoc_insertion_point(class_scope:toptraer.oscar.AccountAck.OrderInfo)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_buy();
  inline void clear_has_buy();
  inline void set_has_open();
  inline void clear_has_open();
  inline void set_has_commissionslot();
  inline void clear_has_commissionslot();
  inline void set_has_commissionprice();
  inline void clear_has_commissionprice();
  inline void set_has_settleslot();
  inline void clear_has_settleslot();
  inline void set_has_settleprice();
  inline void clear_has_settleprice();
  inline void set_has_unsettleslot();
  inline void clear_has_unsettleslot();
  inline void set_has_commissiontime();
  inline void clear_has_commissiontime();
  inline void set_has_declaretime();
  inline void clear_has_declaretime();
  inline void set_has_canceltime();
  inline void clear_has_canceltime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* code_;
  ::std::string* status_;
  ::google::protobuf::uint32 orderid_;
  bool buy_;
  bool open_;
  ::google::protobuf::uint32 commissionslot_;
  float commissionprice_;
  ::google::protobuf::uint32 settleslot_;
  float settleprice_;
  ::std::string* commissiontime_;
  ::std::string* declaretime_;
  ::std::string* canceltime_;
  ::google::protobuf::uint32 unsettleslot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_toptrader_2eproto();
  friend void protobuf_AssignDesc_toptrader_2eproto();
  friend void protobuf_ShutdownFile_toptrader_2eproto();

  void InitAsDefaultInstance();
  static AccountAck_OrderInfo* default_instance_;
};
// -------------------------------------------------------------------

class AccountAck_PositionInfo : public ::google::protobuf::Message {
 public:
  AccountAck_PositionInfo();
  virtual ~AccountAck_PositionInfo();

  AccountAck_PositionInfo(const AccountAck_PositionInfo& from);

  inline AccountAck_PositionInfo& operator=(const AccountAck_PositionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountAck_PositionInfo& default_instance();

  void Swap(AccountAck_PositionInfo* other);

  // implements Message ----------------------------------------------

  AccountAck_PositionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountAck_PositionInfo& from);
  void MergeFrom(const AccountAck_PositionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // required uint32 buyslot = 2;
  inline bool has_buyslot() const;
  inline void clear_buyslot();
  static const int kBuyslotFieldNumber = 2;
  inline ::google::protobuf::uint32 buyslot() const;
  inline void set_buyslot(::google::protobuf::uint32 value);

  // required float buyprice = 3;
  inline bool has_buyprice() const;
  inline void clear_buyprice();
  static const int kBuypriceFieldNumber = 3;
  inline float buyprice() const;
  inline void set_buyprice(float value);

  // required uint32 sellslot = 4;
  inline bool has_sellslot() const;
  inline void clear_sellslot();
  static const int kSellslotFieldNumber = 4;
  inline ::google::protobuf::uint32 sellslot() const;
  inline void set_sellslot(::google::protobuf::uint32 value);

  // required float sellprice = 5;
  inline bool has_sellprice() const;
  inline void clear_sellprice();
  static const int kSellpriceFieldNumber = 5;
  inline float sellprice() const;
  inline void set_sellprice(float value);

  // required uint32 todaybuyslot = 6;
  inline bool has_todaybuyslot() const;
  inline void clear_todaybuyslot();
  static const int kTodaybuyslotFieldNumber = 6;
  inline ::google::protobuf::uint32 todaybuyslot() const;
  inline void set_todaybuyslot(::google::protobuf::uint32 value);

  // required uint32 todaysellslot = 7;
  inline bool has_todaysellslot() const;
  inline void clear_todaysellslot();
  static const int kTodaysellslotFieldNumber = 7;
  inline ::google::protobuf::uint32 todaysellslot() const;
  inline void set_todaysellslot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:toptraer.oscar.AccountAck.PositionInfo)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_buyslot();
  inline void clear_has_buyslot();
  inline void set_has_buyprice();
  inline void clear_has_buyprice();
  inline void set_has_sellslot();
  inline void clear_has_sellslot();
  inline void set_has_sellprice();
  inline void clear_has_sellprice();
  inline void set_has_todaybuyslot();
  inline void clear_has_todaybuyslot();
  inline void set_has_todaysellslot();
  inline void clear_has_todaysellslot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* code_;
  ::google::protobuf::uint32 buyslot_;
  float buyprice_;
  ::google::protobuf::uint32 sellslot_;
  float sellprice_;
  ::google::protobuf::uint32 todaybuyslot_;
  ::google::protobuf::uint32 todaysellslot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_toptrader_2eproto();
  friend void protobuf_AssignDesc_toptrader_2eproto();
  friend void protobuf_ShutdownFile_toptrader_2eproto();

  void InitAsDefaultInstance();
  static AccountAck_PositionInfo* default_instance_;
};
// -------------------------------------------------------------------

class AccountAck : public ::google::protobuf::Message {
 public:
  AccountAck();
  virtual ~AccountAck();

  AccountAck(const AccountAck& from);

  inline AccountAck& operator=(const AccountAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountAck& default_instance();

  void Swap(AccountAck* other);

  // implements Message ----------------------------------------------

  AccountAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountAck& from);
  void MergeFrom(const AccountAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AccountAck_AccountInfo AccountInfo;
  typedef AccountAck_OrderInfo OrderInfo;
  typedef AccountAck_PositionInfo PositionInfo;

  // accessors -------------------------------------------------------

  // required .toptraer.oscar.AccountAck.AccountInfo accinfo = 1;
  inline bool has_accinfo() const;
  inline void clear_accinfo();
  static const int kAccinfoFieldNumber = 1;
  inline const ::toptraer::oscar::AccountAck_AccountInfo& accinfo() const;
  inline ::toptraer::oscar::AccountAck_AccountInfo* mutable_accinfo();
  inline ::toptraer::oscar::AccountAck_AccountInfo* release_accinfo();
  inline void set_allocated_accinfo(::toptraer::oscar::AccountAck_AccountInfo* accinfo);

  // repeated .toptraer.oscar.AccountAck.OrderInfo orderinfo = 2;
  inline int orderinfo_size() const;
  inline void clear_orderinfo();
  static const int kOrderinfoFieldNumber = 2;
  inline const ::toptraer::oscar::AccountAck_OrderInfo& orderinfo(int index) const;
  inline ::toptraer::oscar::AccountAck_OrderInfo* mutable_orderinfo(int index);
  inline ::toptraer::oscar::AccountAck_OrderInfo* add_orderinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_OrderInfo >&
      orderinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_OrderInfo >*
      mutable_orderinfo();

  // repeated .toptraer.oscar.AccountAck.PositionInfo positioninfo = 3;
  inline int positioninfo_size() const;
  inline void clear_positioninfo();
  static const int kPositioninfoFieldNumber = 3;
  inline const ::toptraer::oscar::AccountAck_PositionInfo& positioninfo(int index) const;
  inline ::toptraer::oscar::AccountAck_PositionInfo* mutable_positioninfo(int index);
  inline ::toptraer::oscar::AccountAck_PositionInfo* add_positioninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_PositionInfo >&
      positioninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_PositionInfo >*
      mutable_positioninfo();

  // @@protoc_insertion_point(class_scope:toptraer.oscar.AccountAck)
 private:
  inline void set_has_accinfo();
  inline void clear_has_accinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::toptraer::oscar::AccountAck_AccountInfo* accinfo_;
  ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_OrderInfo > orderinfo_;
  ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_PositionInfo > positioninfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_toptrader_2eproto();
  friend void protobuf_AssignDesc_toptrader_2eproto();
  friend void protobuf_ShutdownFile_toptrader_2eproto();

  void InitAsDefaultInstance();
  static AccountAck* default_instance_;
};
// ===================================================================


// ===================================================================

// GenHeader

// required uint32 magic = 1;
inline bool GenHeader::has_magic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenHeader::set_has_magic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenHeader::clear_has_magic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenHeader::clear_magic() {
  magic_ = 0u;
  clear_has_magic();
}
inline ::google::protobuf::uint32 GenHeader::magic() const {
  return magic_;
}
inline void GenHeader::set_magic(::google::protobuf::uint32 value) {
  set_has_magic();
  magic_ = value;
}

// required uint32 len = 2;
inline bool GenHeader::has_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenHeader::set_has_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenHeader::clear_has_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenHeader::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 GenHeader::len() const {
  return len_;
}
inline void GenHeader::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// required uint32 tag = 3;
inline bool GenHeader::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GenHeader::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GenHeader::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GenHeader::clear_tag() {
  tag_ = 0u;
  clear_has_tag();
}
inline ::google::protobuf::uint32 GenHeader::tag() const {
  return tag_;
}
inline void GenHeader::set_tag(::google::protobuf::uint32 value) {
  set_has_tag();
  tag_ = value;
}

// -------------------------------------------------------------------

// LoginCmd

// required string account = 1;
inline bool LoginCmd::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginCmd::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginCmd::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginCmd::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& LoginCmd::account() const {
  return *account_;
}
inline void LoginCmd::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginCmd::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginCmd::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCmd::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* LoginCmd::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginCmd::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool LoginCmd::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginCmd::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginCmd::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginCmd::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginCmd::password() const {
  return *password_;
}
inline void LoginCmd::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginCmd::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginCmd::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCmd::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginCmd::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginCmd::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginAck

// required bool success = 1;
inline bool LoginAck::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAck::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAck::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAck::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool LoginAck::success() const {
  return success_;
}
inline void LoginAck::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string errcode = 2;
inline bool LoginAck::has_errcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginAck::set_has_errcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginAck::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginAck::clear_errcode() {
  if (errcode_ != &::google::protobuf::internal::kEmptyString) {
    errcode_->clear();
  }
  clear_has_errcode();
}
inline const ::std::string& LoginAck::errcode() const {
  return *errcode_;
}
inline void LoginAck::set_errcode(const ::std::string& value) {
  set_has_errcode();
  if (errcode_ == &::google::protobuf::internal::kEmptyString) {
    errcode_ = new ::std::string;
  }
  errcode_->assign(value);
}
inline void LoginAck::set_errcode(const char* value) {
  set_has_errcode();
  if (errcode_ == &::google::protobuf::internal::kEmptyString) {
    errcode_ = new ::std::string;
  }
  errcode_->assign(value);
}
inline void LoginAck::set_errcode(const char* value, size_t size) {
  set_has_errcode();
  if (errcode_ == &::google::protobuf::internal::kEmptyString) {
    errcode_ = new ::std::string;
  }
  errcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginAck::mutable_errcode() {
  set_has_errcode();
  if (errcode_ == &::google::protobuf::internal::kEmptyString) {
    errcode_ = new ::std::string;
  }
  return errcode_;
}
inline ::std::string* LoginAck::release_errcode() {
  clear_has_errcode();
  if (errcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errcode_;
    errcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginAck::set_allocated_errcode(::std::string* errcode) {
  if (errcode_ != &::google::protobuf::internal::kEmptyString) {
    delete errcode_;
  }
  if (errcode) {
    set_has_errcode();
    errcode_ = errcode;
  } else {
    clear_has_errcode();
    errcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccountQuery

// required string account = 1;
inline bool AccountQuery::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountQuery::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountQuery::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountQuery::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& AccountQuery::account() const {
  return *account_;
}
inline void AccountQuery::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void AccountQuery::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void AccountQuery::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountQuery::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* AccountQuery::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountQuery::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccountAck_AccountInfo

// required string account = 1;
inline bool AccountAck_AccountInfo::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountAck_AccountInfo::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountAck_AccountInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountAck_AccountInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& AccountAck_AccountInfo::account() const {
  return *account_;
}
inline void AccountAck_AccountInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void AccountAck_AccountInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void AccountAck_AccountInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountAck_AccountInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* AccountAck_AccountInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountAck_AccountInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float balance = 2;
inline bool AccountAck_AccountInfo::has_balance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountAck_AccountInfo::set_has_balance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountAck_AccountInfo::clear_has_balance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountAck_AccountInfo::clear_balance() {
  balance_ = 0;
  clear_has_balance();
}
inline float AccountAck_AccountInfo::balance() const {
  return balance_;
}
inline void AccountAck_AccountInfo::set_balance(float value) {
  set_has_balance();
  balance_ = value;
}

// required float available = 3;
inline bool AccountAck_AccountInfo::has_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountAck_AccountInfo::set_has_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountAck_AccountInfo::clear_has_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountAck_AccountInfo::clear_available() {
  available_ = 0;
  clear_has_available();
}
inline float AccountAck_AccountInfo::available() const {
  return available_;
}
inline void AccountAck_AccountInfo::set_available(float value) {
  set_has_available();
  available_ = value;
}

// optional float lastbalance = 4;
inline bool AccountAck_AccountInfo::has_lastbalance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountAck_AccountInfo::set_has_lastbalance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountAck_AccountInfo::clear_has_lastbalance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountAck_AccountInfo::clear_lastbalance() {
  lastbalance_ = 0;
  clear_has_lastbalance();
}
inline float AccountAck_AccountInfo::lastbalance() const {
  return lastbalance_;
}
inline void AccountAck_AccountInfo::set_lastbalance(float value) {
  set_has_lastbalance();
  lastbalance_ = value;
}

// optional float buyfreeze = 5;
inline bool AccountAck_AccountInfo::has_buyfreeze() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountAck_AccountInfo::set_has_buyfreeze() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountAck_AccountInfo::clear_has_buyfreeze() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountAck_AccountInfo::clear_buyfreeze() {
  buyfreeze_ = 0;
  clear_has_buyfreeze();
}
inline float AccountAck_AccountInfo::buyfreeze() const {
  return buyfreeze_;
}
inline void AccountAck_AccountInfo::set_buyfreeze(float value) {
  set_has_buyfreeze();
  buyfreeze_ = value;
}

// optional float sellfreeze = 6;
inline bool AccountAck_AccountInfo::has_sellfreeze() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountAck_AccountInfo::set_has_sellfreeze() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountAck_AccountInfo::clear_has_sellfreeze() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountAck_AccountInfo::clear_sellfreeze() {
  sellfreeze_ = 0;
  clear_has_sellfreeze();
}
inline float AccountAck_AccountInfo::sellfreeze() const {
  return sellfreeze_;
}
inline void AccountAck_AccountInfo::set_sellfreeze(float value) {
  set_has_sellfreeze();
  sellfreeze_ = value;
}

// optional float buymargin = 7;
inline bool AccountAck_AccountInfo::has_buymargin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountAck_AccountInfo::set_has_buymargin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountAck_AccountInfo::clear_has_buymargin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountAck_AccountInfo::clear_buymargin() {
  buymargin_ = 0;
  clear_has_buymargin();
}
inline float AccountAck_AccountInfo::buymargin() const {
  return buymargin_;
}
inline void AccountAck_AccountInfo::set_buymargin(float value) {
  set_has_buymargin();
  buymargin_ = value;
}

// optional float sellmargin = 8;
inline bool AccountAck_AccountInfo::has_sellmargin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AccountAck_AccountInfo::set_has_sellmargin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AccountAck_AccountInfo::clear_has_sellmargin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AccountAck_AccountInfo::clear_sellmargin() {
  sellmargin_ = 0;
  clear_has_sellmargin();
}
inline float AccountAck_AccountInfo::sellmargin() const {
  return sellmargin_;
}
inline void AccountAck_AccountInfo::set_sellmargin(float value) {
  set_has_sellmargin();
  sellmargin_ = value;
}

// optional float settleprofit = 9;
inline bool AccountAck_AccountInfo::has_settleprofit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AccountAck_AccountInfo::set_has_settleprofit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AccountAck_AccountInfo::clear_has_settleprofit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AccountAck_AccountInfo::clear_settleprofit() {
  settleprofit_ = 0;
  clear_has_settleprofit();
}
inline float AccountAck_AccountInfo::settleprofit() const {
  return settleprofit_;
}
inline void AccountAck_AccountInfo::set_settleprofit(float value) {
  set_has_settleprofit();
  settleprofit_ = value;
}

// optional float fee = 10;
inline bool AccountAck_AccountInfo::has_fee() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AccountAck_AccountInfo::set_has_fee() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AccountAck_AccountInfo::clear_has_fee() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AccountAck_AccountInfo::clear_fee() {
  fee_ = 0;
  clear_has_fee();
}
inline float AccountAck_AccountInfo::fee() const {
  return fee_;
}
inline void AccountAck_AccountInfo::set_fee(float value) {
  set_has_fee();
  fee_ = value;
}

// -------------------------------------------------------------------

// AccountAck_OrderInfo

// required uint32 orderid = 1;
inline bool AccountAck_OrderInfo::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountAck_OrderInfo::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountAck_OrderInfo::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountAck_OrderInfo::clear_orderid() {
  orderid_ = 0u;
  clear_has_orderid();
}
inline ::google::protobuf::uint32 AccountAck_OrderInfo::orderid() const {
  return orderid_;
}
inline void AccountAck_OrderInfo::set_orderid(::google::protobuf::uint32 value) {
  set_has_orderid();
  orderid_ = value;
}

// required string code = 2;
inline bool AccountAck_OrderInfo::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountAck_OrderInfo::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountAck_OrderInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountAck_OrderInfo::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& AccountAck_OrderInfo::code() const {
  return *code_;
}
inline void AccountAck_OrderInfo::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void AccountAck_OrderInfo::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void AccountAck_OrderInfo::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountAck_OrderInfo::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* AccountAck_OrderInfo::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountAck_OrderInfo::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string status = 3;
inline bool AccountAck_OrderInfo::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountAck_OrderInfo::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountAck_OrderInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountAck_OrderInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& AccountAck_OrderInfo::status() const {
  return *status_;
}
inline void AccountAck_OrderInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void AccountAck_OrderInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void AccountAck_OrderInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountAck_OrderInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* AccountAck_OrderInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountAck_OrderInfo::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool buy = 4;
inline bool AccountAck_OrderInfo::has_buy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountAck_OrderInfo::set_has_buy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountAck_OrderInfo::clear_has_buy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountAck_OrderInfo::clear_buy() {
  buy_ = false;
  clear_has_buy();
}
inline bool AccountAck_OrderInfo::buy() const {
  return buy_;
}
inline void AccountAck_OrderInfo::set_buy(bool value) {
  set_has_buy();
  buy_ = value;
}

// required bool open = 5;
inline bool AccountAck_OrderInfo::has_open() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountAck_OrderInfo::set_has_open() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountAck_OrderInfo::clear_has_open() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountAck_OrderInfo::clear_open() {
  open_ = false;
  clear_has_open();
}
inline bool AccountAck_OrderInfo::open() const {
  return open_;
}
inline void AccountAck_OrderInfo::set_open(bool value) {
  set_has_open();
  open_ = value;
}

// required uint32 commissionslot = 6;
inline bool AccountAck_OrderInfo::has_commissionslot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountAck_OrderInfo::set_has_commissionslot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountAck_OrderInfo::clear_has_commissionslot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountAck_OrderInfo::clear_commissionslot() {
  commissionslot_ = 0u;
  clear_has_commissionslot();
}
inline ::google::protobuf::uint32 AccountAck_OrderInfo::commissionslot() const {
  return commissionslot_;
}
inline void AccountAck_OrderInfo::set_commissionslot(::google::protobuf::uint32 value) {
  set_has_commissionslot();
  commissionslot_ = value;
}

// required float commissionprice = 7;
inline bool AccountAck_OrderInfo::has_commissionprice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountAck_OrderInfo::set_has_commissionprice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountAck_OrderInfo::clear_has_commissionprice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountAck_OrderInfo::clear_commissionprice() {
  commissionprice_ = 0;
  clear_has_commissionprice();
}
inline float AccountAck_OrderInfo::commissionprice() const {
  return commissionprice_;
}
inline void AccountAck_OrderInfo::set_commissionprice(float value) {
  set_has_commissionprice();
  commissionprice_ = value;
}

// required uint32 settleslot = 8;
inline bool AccountAck_OrderInfo::has_settleslot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AccountAck_OrderInfo::set_has_settleslot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AccountAck_OrderInfo::clear_has_settleslot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AccountAck_OrderInfo::clear_settleslot() {
  settleslot_ = 0u;
  clear_has_settleslot();
}
inline ::google::protobuf::uint32 AccountAck_OrderInfo::settleslot() const {
  return settleslot_;
}
inline void AccountAck_OrderInfo::set_settleslot(::google::protobuf::uint32 value) {
  set_has_settleslot();
  settleslot_ = value;
}

// required float settleprice = 9;
inline bool AccountAck_OrderInfo::has_settleprice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AccountAck_OrderInfo::set_has_settleprice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AccountAck_OrderInfo::clear_has_settleprice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AccountAck_OrderInfo::clear_settleprice() {
  settleprice_ = 0;
  clear_has_settleprice();
}
inline float AccountAck_OrderInfo::settleprice() const {
  return settleprice_;
}
inline void AccountAck_OrderInfo::set_settleprice(float value) {
  set_has_settleprice();
  settleprice_ = value;
}

// required uint32 unsettleslot = 10;
inline bool AccountAck_OrderInfo::has_unsettleslot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AccountAck_OrderInfo::set_has_unsettleslot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AccountAck_OrderInfo::clear_has_unsettleslot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AccountAck_OrderInfo::clear_unsettleslot() {
  unsettleslot_ = 0u;
  clear_has_unsettleslot();
}
inline ::google::protobuf::uint32 AccountAck_OrderInfo::unsettleslot() const {
  return unsettleslot_;
}
inline void AccountAck_OrderInfo::set_unsettleslot(::google::protobuf::uint32 value) {
  set_has_unsettleslot();
  unsettleslot_ = value;
}

// required string commissiontime = 11;
inline bool AccountAck_OrderInfo::has_commissiontime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AccountAck_OrderInfo::set_has_commissiontime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AccountAck_OrderInfo::clear_has_commissiontime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AccountAck_OrderInfo::clear_commissiontime() {
  if (commissiontime_ != &::google::protobuf::internal::kEmptyString) {
    commissiontime_->clear();
  }
  clear_has_commissiontime();
}
inline const ::std::string& AccountAck_OrderInfo::commissiontime() const {
  return *commissiontime_;
}
inline void AccountAck_OrderInfo::set_commissiontime(const ::std::string& value) {
  set_has_commissiontime();
  if (commissiontime_ == &::google::protobuf::internal::kEmptyString) {
    commissiontime_ = new ::std::string;
  }
  commissiontime_->assign(value);
}
inline void AccountAck_OrderInfo::set_commissiontime(const char* value) {
  set_has_commissiontime();
  if (commissiontime_ == &::google::protobuf::internal::kEmptyString) {
    commissiontime_ = new ::std::string;
  }
  commissiontime_->assign(value);
}
inline void AccountAck_OrderInfo::set_commissiontime(const char* value, size_t size) {
  set_has_commissiontime();
  if (commissiontime_ == &::google::protobuf::internal::kEmptyString) {
    commissiontime_ = new ::std::string;
  }
  commissiontime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountAck_OrderInfo::mutable_commissiontime() {
  set_has_commissiontime();
  if (commissiontime_ == &::google::protobuf::internal::kEmptyString) {
    commissiontime_ = new ::std::string;
  }
  return commissiontime_;
}
inline ::std::string* AccountAck_OrderInfo::release_commissiontime() {
  clear_has_commissiontime();
  if (commissiontime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commissiontime_;
    commissiontime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountAck_OrderInfo::set_allocated_commissiontime(::std::string* commissiontime) {
  if (commissiontime_ != &::google::protobuf::internal::kEmptyString) {
    delete commissiontime_;
  }
  if (commissiontime) {
    set_has_commissiontime();
    commissiontime_ = commissiontime;
  } else {
    clear_has_commissiontime();
    commissiontime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string declaretime = 12;
inline bool AccountAck_OrderInfo::has_declaretime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AccountAck_OrderInfo::set_has_declaretime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AccountAck_OrderInfo::clear_has_declaretime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AccountAck_OrderInfo::clear_declaretime() {
  if (declaretime_ != &::google::protobuf::internal::kEmptyString) {
    declaretime_->clear();
  }
  clear_has_declaretime();
}
inline const ::std::string& AccountAck_OrderInfo::declaretime() const {
  return *declaretime_;
}
inline void AccountAck_OrderInfo::set_declaretime(const ::std::string& value) {
  set_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    declaretime_ = new ::std::string;
  }
  declaretime_->assign(value);
}
inline void AccountAck_OrderInfo::set_declaretime(const char* value) {
  set_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    declaretime_ = new ::std::string;
  }
  declaretime_->assign(value);
}
inline void AccountAck_OrderInfo::set_declaretime(const char* value, size_t size) {
  set_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    declaretime_ = new ::std::string;
  }
  declaretime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountAck_OrderInfo::mutable_declaretime() {
  set_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    declaretime_ = new ::std::string;
  }
  return declaretime_;
}
inline ::std::string* AccountAck_OrderInfo::release_declaretime() {
  clear_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = declaretime_;
    declaretime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountAck_OrderInfo::set_allocated_declaretime(::std::string* declaretime) {
  if (declaretime_ != &::google::protobuf::internal::kEmptyString) {
    delete declaretime_;
  }
  if (declaretime) {
    set_has_declaretime();
    declaretime_ = declaretime;
  } else {
    clear_has_declaretime();
    declaretime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string canceltime = 13;
inline bool AccountAck_OrderInfo::has_canceltime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AccountAck_OrderInfo::set_has_canceltime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AccountAck_OrderInfo::clear_has_canceltime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AccountAck_OrderInfo::clear_canceltime() {
  if (canceltime_ != &::google::protobuf::internal::kEmptyString) {
    canceltime_->clear();
  }
  clear_has_canceltime();
}
inline const ::std::string& AccountAck_OrderInfo::canceltime() const {
  return *canceltime_;
}
inline void AccountAck_OrderInfo::set_canceltime(const ::std::string& value) {
  set_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    canceltime_ = new ::std::string;
  }
  canceltime_->assign(value);
}
inline void AccountAck_OrderInfo::set_canceltime(const char* value) {
  set_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    canceltime_ = new ::std::string;
  }
  canceltime_->assign(value);
}
inline void AccountAck_OrderInfo::set_canceltime(const char* value, size_t size) {
  set_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    canceltime_ = new ::std::string;
  }
  canceltime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountAck_OrderInfo::mutable_canceltime() {
  set_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    canceltime_ = new ::std::string;
  }
  return canceltime_;
}
inline ::std::string* AccountAck_OrderInfo::release_canceltime() {
  clear_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = canceltime_;
    canceltime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountAck_OrderInfo::set_allocated_canceltime(::std::string* canceltime) {
  if (canceltime_ != &::google::protobuf::internal::kEmptyString) {
    delete canceltime_;
  }
  if (canceltime) {
    set_has_canceltime();
    canceltime_ = canceltime;
  } else {
    clear_has_canceltime();
    canceltime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccountAck_PositionInfo

// required string code = 1;
inline bool AccountAck_PositionInfo::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountAck_PositionInfo::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountAck_PositionInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountAck_PositionInfo::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& AccountAck_PositionInfo::code() const {
  return *code_;
}
inline void AccountAck_PositionInfo::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void AccountAck_PositionInfo::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void AccountAck_PositionInfo::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountAck_PositionInfo::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* AccountAck_PositionInfo::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountAck_PositionInfo::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 buyslot = 2;
inline bool AccountAck_PositionInfo::has_buyslot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountAck_PositionInfo::set_has_buyslot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountAck_PositionInfo::clear_has_buyslot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountAck_PositionInfo::clear_buyslot() {
  buyslot_ = 0u;
  clear_has_buyslot();
}
inline ::google::protobuf::uint32 AccountAck_PositionInfo::buyslot() const {
  return buyslot_;
}
inline void AccountAck_PositionInfo::set_buyslot(::google::protobuf::uint32 value) {
  set_has_buyslot();
  buyslot_ = value;
}

// required float buyprice = 3;
inline bool AccountAck_PositionInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountAck_PositionInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountAck_PositionInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountAck_PositionInfo::clear_buyprice() {
  buyprice_ = 0;
  clear_has_buyprice();
}
inline float AccountAck_PositionInfo::buyprice() const {
  return buyprice_;
}
inline void AccountAck_PositionInfo::set_buyprice(float value) {
  set_has_buyprice();
  buyprice_ = value;
}

// required uint32 sellslot = 4;
inline bool AccountAck_PositionInfo::has_sellslot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountAck_PositionInfo::set_has_sellslot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountAck_PositionInfo::clear_has_sellslot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountAck_PositionInfo::clear_sellslot() {
  sellslot_ = 0u;
  clear_has_sellslot();
}
inline ::google::protobuf::uint32 AccountAck_PositionInfo::sellslot() const {
  return sellslot_;
}
inline void AccountAck_PositionInfo::set_sellslot(::google::protobuf::uint32 value) {
  set_has_sellslot();
  sellslot_ = value;
}

// required float sellprice = 5;
inline bool AccountAck_PositionInfo::has_sellprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountAck_PositionInfo::set_has_sellprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountAck_PositionInfo::clear_has_sellprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountAck_PositionInfo::clear_sellprice() {
  sellprice_ = 0;
  clear_has_sellprice();
}
inline float AccountAck_PositionInfo::sellprice() const {
  return sellprice_;
}
inline void AccountAck_PositionInfo::set_sellprice(float value) {
  set_has_sellprice();
  sellprice_ = value;
}

// required uint32 todaybuyslot = 6;
inline bool AccountAck_PositionInfo::has_todaybuyslot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountAck_PositionInfo::set_has_todaybuyslot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountAck_PositionInfo::clear_has_todaybuyslot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountAck_PositionInfo::clear_todaybuyslot() {
  todaybuyslot_ = 0u;
  clear_has_todaybuyslot();
}
inline ::google::protobuf::uint32 AccountAck_PositionInfo::todaybuyslot() const {
  return todaybuyslot_;
}
inline void AccountAck_PositionInfo::set_todaybuyslot(::google::protobuf::uint32 value) {
  set_has_todaybuyslot();
  todaybuyslot_ = value;
}

// required uint32 todaysellslot = 7;
inline bool AccountAck_PositionInfo::has_todaysellslot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountAck_PositionInfo::set_has_todaysellslot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountAck_PositionInfo::clear_has_todaysellslot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountAck_PositionInfo::clear_todaysellslot() {
  todaysellslot_ = 0u;
  clear_has_todaysellslot();
}
inline ::google::protobuf::uint32 AccountAck_PositionInfo::todaysellslot() const {
  return todaysellslot_;
}
inline void AccountAck_PositionInfo::set_todaysellslot(::google::protobuf::uint32 value) {
  set_has_todaysellslot();
  todaysellslot_ = value;
}

// -------------------------------------------------------------------

// AccountAck

// required .toptraer.oscar.AccountAck.AccountInfo accinfo = 1;
inline bool AccountAck::has_accinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountAck::set_has_accinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountAck::clear_has_accinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountAck::clear_accinfo() {
  if (accinfo_ != NULL) accinfo_->::toptraer::oscar::AccountAck_AccountInfo::Clear();
  clear_has_accinfo();
}
inline const ::toptraer::oscar::AccountAck_AccountInfo& AccountAck::accinfo() const {
  return accinfo_ != NULL ? *accinfo_ : *default_instance_->accinfo_;
}
inline ::toptraer::oscar::AccountAck_AccountInfo* AccountAck::mutable_accinfo() {
  set_has_accinfo();
  if (accinfo_ == NULL) accinfo_ = new ::toptraer::oscar::AccountAck_AccountInfo;
  return accinfo_;
}
inline ::toptraer::oscar::AccountAck_AccountInfo* AccountAck::release_accinfo() {
  clear_has_accinfo();
  ::toptraer::oscar::AccountAck_AccountInfo* temp = accinfo_;
  accinfo_ = NULL;
  return temp;
}
inline void AccountAck::set_allocated_accinfo(::toptraer::oscar::AccountAck_AccountInfo* accinfo) {
  delete accinfo_;
  accinfo_ = accinfo;
  if (accinfo) {
    set_has_accinfo();
  } else {
    clear_has_accinfo();
  }
}

// repeated .toptraer.oscar.AccountAck.OrderInfo orderinfo = 2;
inline int AccountAck::orderinfo_size() const {
  return orderinfo_.size();
}
inline void AccountAck::clear_orderinfo() {
  orderinfo_.Clear();
}
inline const ::toptraer::oscar::AccountAck_OrderInfo& AccountAck::orderinfo(int index) const {
  return orderinfo_.Get(index);
}
inline ::toptraer::oscar::AccountAck_OrderInfo* AccountAck::mutable_orderinfo(int index) {
  return orderinfo_.Mutable(index);
}
inline ::toptraer::oscar::AccountAck_OrderInfo* AccountAck::add_orderinfo() {
  return orderinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_OrderInfo >&
AccountAck::orderinfo() const {
  return orderinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_OrderInfo >*
AccountAck::mutable_orderinfo() {
  return &orderinfo_;
}

// repeated .toptraer.oscar.AccountAck.PositionInfo positioninfo = 3;
inline int AccountAck::positioninfo_size() const {
  return positioninfo_.size();
}
inline void AccountAck::clear_positioninfo() {
  positioninfo_.Clear();
}
inline const ::toptraer::oscar::AccountAck_PositionInfo& AccountAck::positioninfo(int index) const {
  return positioninfo_.Get(index);
}
inline ::toptraer::oscar::AccountAck_PositionInfo* AccountAck::mutable_positioninfo(int index) {
  return positioninfo_.Mutable(index);
}
inline ::toptraer::oscar::AccountAck_PositionInfo* AccountAck::add_positioninfo() {
  return positioninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_PositionInfo >&
AccountAck::positioninfo() const {
  return positioninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::toptraer::oscar::AccountAck_PositionInfo >*
AccountAck::mutable_positioninfo() {
  return &positioninfo_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace oscar
}  // namespace toptraer

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_toptrader_2eproto__INCLUDED
