// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: toptrader.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "toptrader.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace toptraer {
namespace oscar {

namespace {

const ::google::protobuf::Descriptor* GenHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GenHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* AccountQuery_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccountQuery_reflection_ = NULL;
const ::google::protobuf::Descriptor* AccountAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccountAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* AccountAck_AccountInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccountAck_AccountInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* AccountAck_OrderInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccountAck_OrderInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* AccountAck_PositionInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccountAck_PositionInfo_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_toptrader_2eproto() {
  protobuf_AddDesc_toptrader_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "toptrader.proto");
  GOOGLE_CHECK(file != NULL);
  GenHeader_descriptor_ = file->message_type(0);
  static const int GenHeader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenHeader, magic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenHeader, len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenHeader, tag_),
  };
  GenHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GenHeader_descriptor_,
      GenHeader::default_instance_,
      GenHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GenHeader));
  LoginCmd_descriptor_ = file->message_type(1);
  static const int LoginCmd_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginCmd, account_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginCmd, password_),
  };
  LoginCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginCmd_descriptor_,
      LoginCmd::default_instance_,
      LoginCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginCmd));
  LoginAck_descriptor_ = file->message_type(2);
  static const int LoginAck_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginAck, success_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginAck, errcode_),
  };
  LoginAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginAck_descriptor_,
      LoginAck::default_instance_,
      LoginAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginAck));
  AccountQuery_descriptor_ = file->message_type(3);
  static const int AccountQuery_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountQuery, account_),
  };
  AccountQuery_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AccountQuery_descriptor_,
      AccountQuery::default_instance_,
      AccountQuery_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountQuery, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountQuery, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AccountQuery));
  AccountAck_descriptor_ = file->message_type(4);
  static const int AccountAck_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck, accinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck, orderinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck, positioninfo_),
  };
  AccountAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AccountAck_descriptor_,
      AccountAck::default_instance_,
      AccountAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AccountAck));
  AccountAck_AccountInfo_descriptor_ = AccountAck_descriptor_->nested_type(0);
  static const int AccountAck_AccountInfo_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, account_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, balance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, available_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, lastbalance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, buyfreeze_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, sellfreeze_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, buymargin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, sellmargin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, settleprofit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, fee_),
  };
  AccountAck_AccountInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AccountAck_AccountInfo_descriptor_,
      AccountAck_AccountInfo::default_instance_,
      AccountAck_AccountInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_AccountInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AccountAck_AccountInfo));
  AccountAck_OrderInfo_descriptor_ = AccountAck_descriptor_->nested_type(1);
  static const int AccountAck_OrderInfo_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, orderid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, buy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, open_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, commissionslot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, commissionprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, settleslot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, settleprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, unsettleslot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, commissiontime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, declaretime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, canceltime_),
  };
  AccountAck_OrderInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AccountAck_OrderInfo_descriptor_,
      AccountAck_OrderInfo::default_instance_,
      AccountAck_OrderInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_OrderInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AccountAck_OrderInfo));
  AccountAck_PositionInfo_descriptor_ = AccountAck_descriptor_->nested_type(2);
  static const int AccountAck_PositionInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, buyslot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, sellslot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, sellprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, todaybuyslot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, todaysellslot_),
  };
  AccountAck_PositionInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AccountAck_PositionInfo_descriptor_,
      AccountAck_PositionInfo::default_instance_,
      AccountAck_PositionInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAck_PositionInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AccountAck_PositionInfo));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_toptrader_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GenHeader_descriptor_, &GenHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginCmd_descriptor_, &LoginCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginAck_descriptor_, &LoginAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AccountQuery_descriptor_, &AccountQuery::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AccountAck_descriptor_, &AccountAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AccountAck_AccountInfo_descriptor_, &AccountAck_AccountInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AccountAck_OrderInfo_descriptor_, &AccountAck_OrderInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AccountAck_PositionInfo_descriptor_, &AccountAck_PositionInfo::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_toptrader_2eproto() {
  delete GenHeader::default_instance_;
  delete GenHeader_reflection_;
  delete LoginCmd::default_instance_;
  delete LoginCmd_reflection_;
  delete LoginAck::default_instance_;
  delete LoginAck_reflection_;
  delete AccountQuery::default_instance_;
  delete AccountQuery_reflection_;
  delete AccountAck::default_instance_;
  delete AccountAck_reflection_;
  delete AccountAck_AccountInfo::default_instance_;
  delete AccountAck_AccountInfo_reflection_;
  delete AccountAck_OrderInfo::default_instance_;
  delete AccountAck_OrderInfo_reflection_;
  delete AccountAck_PositionInfo::default_instance_;
  delete AccountAck_PositionInfo_reflection_;
}

void protobuf_AddDesc_toptrader_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017toptrader.proto\022\016toptraer.oscar\"4\n\tGen"
    "Header\022\r\n\005magic\030\001 \002(\r\022\013\n\003len\030\002 \002(\r\022\013\n\003ta"
    "g\030\003 \002(\r\"-\n\010LoginCmd\022\017\n\007account\030\001 \002(\t\022\020\n\010"
    "password\030\002 \002(\t\",\n\010LoginAck\022\017\n\007success\030\001 "
    "\002(\010\022\017\n\007errcode\030\002 \001(\t\"\037\n\014AccountQuery\022\017\n\007"
    "account\030\001 \002(\t\"\245\006\n\nAccountAck\0227\n\007accinfo\030"
    "\001 \002(\0132&.toptraer.oscar.AccountAck.Accoun"
    "tInfo\0227\n\torderinfo\030\002 \003(\0132$.toptraer.osca"
    "r.AccountAck.OrderInfo\022=\n\014positioninfo\030\003"
    " \003(\0132\'.toptraer.oscar.AccountAck.Positio"
    "nInfo\032\310\001\n\013AccountInfo\022\017\n\007account\030\001 \002(\t\022\017"
    "\n\007balance\030\002 \002(\002\022\021\n\tavailable\030\003 \002(\002\022\023\n\013la"
    "stbalance\030\004 \001(\002\022\021\n\tbuyfreeze\030\005 \001(\002\022\022\n\nse"
    "llfreeze\030\006 \001(\002\022\021\n\tbuymargin\030\007 \001(\002\022\022\n\nsel"
    "lmargin\030\010 \001(\002\022\024\n\014settleprofit\030\t \001(\002\022\013\n\003f"
    "ee\030\n \001(\002\032\206\002\n\tOrderInfo\022\017\n\007orderid\030\001 \002(\r\022"
    "\014\n\004code\030\002 \002(\t\022\016\n\006status\030\003 \002(\t\022\013\n\003buy\030\004 \002"
    "(\010\022\014\n\004open\030\005 \002(\010\022\026\n\016commissionslot\030\006 \002(\r"
    "\022\027\n\017commissionprice\030\007 \002(\002\022\022\n\nsettleslot\030"
    "\010 \002(\r\022\023\n\013settleprice\030\t \002(\002\022\024\n\014unsettlesl"
    "ot\030\n \002(\r\022\026\n\016commissiontime\030\013 \002(\t\022\023\n\013decl"
    "aretime\030\014 \002(\t\022\022\n\ncanceltime\030\r \002(\t\032\221\001\n\014Po"
    "sitionInfo\022\014\n\004code\030\001 \002(\t\022\017\n\007buyslot\030\002 \002("
    "\r\022\020\n\010buyprice\030\003 \002(\002\022\020\n\010sellslot\030\004 \002(\r\022\021\n"
    "\tsellprice\030\005 \002(\002\022\024\n\014todaybuyslot\030\006 \002(\r\022\025"
    "\n\rtodaysellslot\030\007 \002(\r", 1021);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "toptrader.proto", &protobuf_RegisterTypes);
  GenHeader::default_instance_ = new GenHeader();
  LoginCmd::default_instance_ = new LoginCmd();
  LoginAck::default_instance_ = new LoginAck();
  AccountQuery::default_instance_ = new AccountQuery();
  AccountAck::default_instance_ = new AccountAck();
  AccountAck_AccountInfo::default_instance_ = new AccountAck_AccountInfo();
  AccountAck_OrderInfo::default_instance_ = new AccountAck_OrderInfo();
  AccountAck_PositionInfo::default_instance_ = new AccountAck_PositionInfo();
  GenHeader::default_instance_->InitAsDefaultInstance();
  LoginCmd::default_instance_->InitAsDefaultInstance();
  LoginAck::default_instance_->InitAsDefaultInstance();
  AccountQuery::default_instance_->InitAsDefaultInstance();
  AccountAck::default_instance_->InitAsDefaultInstance();
  AccountAck_AccountInfo::default_instance_->InitAsDefaultInstance();
  AccountAck_OrderInfo::default_instance_->InitAsDefaultInstance();
  AccountAck_PositionInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_toptrader_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_toptrader_2eproto {
  StaticDescriptorInitializer_toptrader_2eproto() {
    protobuf_AddDesc_toptrader_2eproto();
  }
} static_descriptor_initializer_toptrader_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int GenHeader::kMagicFieldNumber;
const int GenHeader::kLenFieldNumber;
const int GenHeader::kTagFieldNumber;
#endif  // !_MSC_VER

GenHeader::GenHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GenHeader::InitAsDefaultInstance() {
}

GenHeader::GenHeader(const GenHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GenHeader::SharedCtor() {
  _cached_size_ = 0;
  magic_ = 0u;
  len_ = 0u;
  tag_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GenHeader::~GenHeader() {
  SharedDtor();
}

void GenHeader::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GenHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GenHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GenHeader_descriptor_;
}

const GenHeader& GenHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_toptrader_2eproto();
  return *default_instance_;
}

GenHeader* GenHeader::default_instance_ = NULL;

GenHeader* GenHeader::New() const {
  return new GenHeader;
}

void GenHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    magic_ = 0u;
    len_ = 0u;
    tag_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GenHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 magic = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &magic_)));
          set_has_magic();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_len;
        break;
      }

      // required uint32 len = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
          set_has_len();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_tag;
        break;
      }

      // required uint32 tag = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tag_)));
          set_has_tag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GenHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 magic = 1;
  if (has_magic()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->magic(), output);
  }

  // required uint32 len = 2;
  if (has_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->len(), output);
  }

  // required uint32 tag = 3;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->tag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GenHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 magic = 1;
  if (has_magic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->magic(), target);
  }

  // required uint32 len = 2;
  if (has_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->len(), target);
  }

  // required uint32 tag = 3;
  if (has_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->tag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GenHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 magic = 1;
    if (has_magic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->magic());
    }

    // required uint32 len = 2;
    if (has_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // required uint32 tag = 3;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tag());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GenHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GenHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GenHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GenHeader::MergeFrom(const GenHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_magic()) {
      set_magic(from.magic());
    }
    if (from.has_len()) {
      set_len(from.len());
    }
    if (from.has_tag()) {
      set_tag(from.tag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GenHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GenHeader::CopyFrom(const GenHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GenHeader::Swap(GenHeader* other) {
  if (other != this) {
    std::swap(magic_, other->magic_);
    std::swap(len_, other->len_);
    std::swap(tag_, other->tag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GenHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GenHeader_descriptor_;
  metadata.reflection = GenHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginCmd::kAccountFieldNumber;
const int LoginCmd::kPasswordFieldNumber;
#endif  // !_MSC_VER

LoginCmd::LoginCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoginCmd::InitAsDefaultInstance() {
}

LoginCmd::LoginCmd(const LoginCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoginCmd::SharedCtor() {
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginCmd::~LoginCmd() {
  SharedDtor();
}

void LoginCmd::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (this != default_instance_) {
  }
}

void LoginCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginCmd_descriptor_;
}

const LoginCmd& LoginCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_toptrader_2eproto();
  return *default_instance_;
}

LoginCmd* LoginCmd::default_instance_ = NULL;

LoginCmd* LoginCmd::New() const {
  return new LoginCmd;
}

void LoginCmd::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::kEmptyString) {
        password_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string account = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->account().data(), this->account().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // required string password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->password().data(), this->password().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->account(), output);
  }

  // required string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->password(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoginCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->account(), target);
  }

  // required string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->password(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoginCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // required string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginCmd::MergeFrom(const LoginCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginCmd::CopyFrom(const LoginCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginCmd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void LoginCmd::Swap(LoginCmd* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(password_, other->password_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginCmd_descriptor_;
  metadata.reflection = LoginCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginAck::kSuccessFieldNumber;
const int LoginAck::kErrcodeFieldNumber;
#endif  // !_MSC_VER

LoginAck::LoginAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoginAck::InitAsDefaultInstance() {
}

LoginAck::LoginAck(const LoginAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoginAck::SharedCtor() {
  _cached_size_ = 0;
  success_ = false;
  errcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginAck::~LoginAck() {
  SharedDtor();
}

void LoginAck::SharedDtor() {
  if (errcode_ != &::google::protobuf::internal::kEmptyString) {
    delete errcode_;
  }
  if (this != default_instance_) {
  }
}

void LoginAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginAck_descriptor_;
}

const LoginAck& LoginAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_toptrader_2eproto();
  return *default_instance_;
}

LoginAck* LoginAck::default_instance_ = NULL;

LoginAck* LoginAck::New() const {
  return new LoginAck;
}

void LoginAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    success_ = false;
    if (has_errcode()) {
      if (errcode_ != &::google::protobuf::internal::kEmptyString) {
        errcode_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool success = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_errcode;
        break;
      }

      // optional string errcode = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_errcode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_errcode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->errcode().data(), this->errcode().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool success = 1;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->success(), output);
  }

  // optional string errcode = 2;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->errcode().data(), this->errcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->errcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoginAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool success = 1;
  if (has_success()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->success(), target);
  }

  // optional string errcode = 2;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->errcode().data(), this->errcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->errcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoginAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool success = 1;
    if (has_success()) {
      total_size += 1 + 1;
    }

    // optional string errcode = 2;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->errcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginAck::MergeFrom(const LoginAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_success()) {
      set_success(from.success());
    }
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginAck::CopyFrom(const LoginAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginAck::Swap(LoginAck* other) {
  if (other != this) {
    std::swap(success_, other->success_);
    std::swap(errcode_, other->errcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginAck_descriptor_;
  metadata.reflection = LoginAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AccountQuery::kAccountFieldNumber;
#endif  // !_MSC_VER

AccountQuery::AccountQuery()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AccountQuery::InitAsDefaultInstance() {
}

AccountQuery::AccountQuery(const AccountQuery& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AccountQuery::SharedCtor() {
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccountQuery::~AccountQuery() {
  SharedDtor();
}

void AccountQuery::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (this != default_instance_) {
  }
}

void AccountQuery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccountQuery::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccountQuery_descriptor_;
}

const AccountQuery& AccountQuery::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_toptrader_2eproto();
  return *default_instance_;
}

AccountQuery* AccountQuery::default_instance_ = NULL;

AccountQuery* AccountQuery::New() const {
  return new AccountQuery;
}

void AccountQuery::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AccountQuery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string account = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->account().data(), this->account().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccountQuery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->account(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AccountQuery::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->account(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AccountQuery::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccountQuery::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AccountQuery* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccountQuery*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccountQuery::MergeFrom(const AccountQuery& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AccountQuery::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccountQuery::CopyFrom(const AccountQuery& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountQuery::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AccountQuery::Swap(AccountQuery* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AccountQuery::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccountQuery_descriptor_;
  metadata.reflection = AccountQuery_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AccountAck_AccountInfo::kAccountFieldNumber;
const int AccountAck_AccountInfo::kBalanceFieldNumber;
const int AccountAck_AccountInfo::kAvailableFieldNumber;
const int AccountAck_AccountInfo::kLastbalanceFieldNumber;
const int AccountAck_AccountInfo::kBuyfreezeFieldNumber;
const int AccountAck_AccountInfo::kSellfreezeFieldNumber;
const int AccountAck_AccountInfo::kBuymarginFieldNumber;
const int AccountAck_AccountInfo::kSellmarginFieldNumber;
const int AccountAck_AccountInfo::kSettleprofitFieldNumber;
const int AccountAck_AccountInfo::kFeeFieldNumber;
#endif  // !_MSC_VER

AccountAck_AccountInfo::AccountAck_AccountInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AccountAck_AccountInfo::InitAsDefaultInstance() {
}

AccountAck_AccountInfo::AccountAck_AccountInfo(const AccountAck_AccountInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AccountAck_AccountInfo::SharedCtor() {
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  balance_ = 0;
  available_ = 0;
  lastbalance_ = 0;
  buyfreeze_ = 0;
  sellfreeze_ = 0;
  buymargin_ = 0;
  sellmargin_ = 0;
  settleprofit_ = 0;
  fee_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccountAck_AccountInfo::~AccountAck_AccountInfo() {
  SharedDtor();
}

void AccountAck_AccountInfo::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (this != default_instance_) {
  }
}

void AccountAck_AccountInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccountAck_AccountInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccountAck_AccountInfo_descriptor_;
}

const AccountAck_AccountInfo& AccountAck_AccountInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_toptrader_2eproto();
  return *default_instance_;
}

AccountAck_AccountInfo* AccountAck_AccountInfo::default_instance_ = NULL;

AccountAck_AccountInfo* AccountAck_AccountInfo::New() const {
  return new AccountAck_AccountInfo;
}

void AccountAck_AccountInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    balance_ = 0;
    available_ = 0;
    lastbalance_ = 0;
    buyfreeze_ = 0;
    sellfreeze_ = 0;
    buymargin_ = 0;
    sellmargin_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    settleprofit_ = 0;
    fee_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AccountAck_AccountInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string account = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->account().data(), this->account().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_balance;
        break;
      }

      // required float balance = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_balance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &balance_)));
          set_has_balance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_available;
        break;
      }

      // required float available = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_available:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &available_)));
          set_has_available();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_lastbalance;
        break;
      }

      // optional float lastbalance = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_lastbalance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lastbalance_)));
          set_has_lastbalance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_buyfreeze;
        break;
      }

      // optional float buyfreeze = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_buyfreeze:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &buyfreeze_)));
          set_has_buyfreeze();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_sellfreeze;
        break;
      }

      // optional float sellfreeze = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sellfreeze:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sellfreeze_)));
          set_has_sellfreeze();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_buymargin;
        break;
      }

      // optional float buymargin = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_buymargin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &buymargin_)));
          set_has_buymargin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_sellmargin;
        break;
      }

      // optional float sellmargin = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sellmargin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sellmargin_)));
          set_has_sellmargin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_settleprofit;
        break;
      }

      // optional float settleprofit = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_settleprofit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &settleprofit_)));
          set_has_settleprofit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_fee;
        break;
      }

      // optional float fee = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fee:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fee_)));
          set_has_fee();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccountAck_AccountInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->account(), output);
  }

  // required float balance = 2;
  if (has_balance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->balance(), output);
  }

  // required float available = 3;
  if (has_available()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->available(), output);
  }

  // optional float lastbalance = 4;
  if (has_lastbalance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->lastbalance(), output);
  }

  // optional float buyfreeze = 5;
  if (has_buyfreeze()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->buyfreeze(), output);
  }

  // optional float sellfreeze = 6;
  if (has_sellfreeze()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->sellfreeze(), output);
  }

  // optional float buymargin = 7;
  if (has_buymargin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->buymargin(), output);
  }

  // optional float sellmargin = 8;
  if (has_sellmargin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->sellmargin(), output);
  }

  // optional float settleprofit = 9;
  if (has_settleprofit()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->settleprofit(), output);
  }

  // optional float fee = 10;
  if (has_fee()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->fee(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AccountAck_AccountInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->account(), target);
  }

  // required float balance = 2;
  if (has_balance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->balance(), target);
  }

  // required float available = 3;
  if (has_available()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->available(), target);
  }

  // optional float lastbalance = 4;
  if (has_lastbalance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->lastbalance(), target);
  }

  // optional float buyfreeze = 5;
  if (has_buyfreeze()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->buyfreeze(), target);
  }

  // optional float sellfreeze = 6;
  if (has_sellfreeze()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->sellfreeze(), target);
  }

  // optional float buymargin = 7;
  if (has_buymargin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->buymargin(), target);
  }

  // optional float sellmargin = 8;
  if (has_sellmargin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->sellmargin(), target);
  }

  // optional float settleprofit = 9;
  if (has_settleprofit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->settleprofit(), target);
  }

  // optional float fee = 10;
  if (has_fee()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->fee(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AccountAck_AccountInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // required float balance = 2;
    if (has_balance()) {
      total_size += 1 + 4;
    }

    // required float available = 3;
    if (has_available()) {
      total_size += 1 + 4;
    }

    // optional float lastbalance = 4;
    if (has_lastbalance()) {
      total_size += 1 + 4;
    }

    // optional float buyfreeze = 5;
    if (has_buyfreeze()) {
      total_size += 1 + 4;
    }

    // optional float sellfreeze = 6;
    if (has_sellfreeze()) {
      total_size += 1 + 4;
    }

    // optional float buymargin = 7;
    if (has_buymargin()) {
      total_size += 1 + 4;
    }

    // optional float sellmargin = 8;
    if (has_sellmargin()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float settleprofit = 9;
    if (has_settleprofit()) {
      total_size += 1 + 4;
    }

    // optional float fee = 10;
    if (has_fee()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccountAck_AccountInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AccountAck_AccountInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccountAck_AccountInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccountAck_AccountInfo::MergeFrom(const AccountAck_AccountInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_balance()) {
      set_balance(from.balance());
    }
    if (from.has_available()) {
      set_available(from.available());
    }
    if (from.has_lastbalance()) {
      set_lastbalance(from.lastbalance());
    }
    if (from.has_buyfreeze()) {
      set_buyfreeze(from.buyfreeze());
    }
    if (from.has_sellfreeze()) {
      set_sellfreeze(from.sellfreeze());
    }
    if (from.has_buymargin()) {
      set_buymargin(from.buymargin());
    }
    if (from.has_sellmargin()) {
      set_sellmargin(from.sellmargin());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_settleprofit()) {
      set_settleprofit(from.settleprofit());
    }
    if (from.has_fee()) {
      set_fee(from.fee());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AccountAck_AccountInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccountAck_AccountInfo::CopyFrom(const AccountAck_AccountInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountAck_AccountInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void AccountAck_AccountInfo::Swap(AccountAck_AccountInfo* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(balance_, other->balance_);
    std::swap(available_, other->available_);
    std::swap(lastbalance_, other->lastbalance_);
    std::swap(buyfreeze_, other->buyfreeze_);
    std::swap(sellfreeze_, other->sellfreeze_);
    std::swap(buymargin_, other->buymargin_);
    std::swap(sellmargin_, other->sellmargin_);
    std::swap(settleprofit_, other->settleprofit_);
    std::swap(fee_, other->fee_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AccountAck_AccountInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccountAck_AccountInfo_descriptor_;
  metadata.reflection = AccountAck_AccountInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AccountAck_OrderInfo::kOrderidFieldNumber;
const int AccountAck_OrderInfo::kCodeFieldNumber;
const int AccountAck_OrderInfo::kStatusFieldNumber;
const int AccountAck_OrderInfo::kBuyFieldNumber;
const int AccountAck_OrderInfo::kOpenFieldNumber;
const int AccountAck_OrderInfo::kCommissionslotFieldNumber;
const int AccountAck_OrderInfo::kCommissionpriceFieldNumber;
const int AccountAck_OrderInfo::kSettleslotFieldNumber;
const int AccountAck_OrderInfo::kSettlepriceFieldNumber;
const int AccountAck_OrderInfo::kUnsettleslotFieldNumber;
const int AccountAck_OrderInfo::kCommissiontimeFieldNumber;
const int AccountAck_OrderInfo::kDeclaretimeFieldNumber;
const int AccountAck_OrderInfo::kCanceltimeFieldNumber;
#endif  // !_MSC_VER

AccountAck_OrderInfo::AccountAck_OrderInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AccountAck_OrderInfo::InitAsDefaultInstance() {
}

AccountAck_OrderInfo::AccountAck_OrderInfo(const AccountAck_OrderInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AccountAck_OrderInfo::SharedCtor() {
  _cached_size_ = 0;
  orderid_ = 0u;
  code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buy_ = false;
  open_ = false;
  commissionslot_ = 0u;
  commissionprice_ = 0;
  settleslot_ = 0u;
  settleprice_ = 0;
  unsettleslot_ = 0u;
  commissiontime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  declaretime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  canceltime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccountAck_OrderInfo::~AccountAck_OrderInfo() {
  SharedDtor();
}

void AccountAck_OrderInfo::SharedDtor() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (commissiontime_ != &::google::protobuf::internal::kEmptyString) {
    delete commissiontime_;
  }
  if (declaretime_ != &::google::protobuf::internal::kEmptyString) {
    delete declaretime_;
  }
  if (canceltime_ != &::google::protobuf::internal::kEmptyString) {
    delete canceltime_;
  }
  if (this != default_instance_) {
  }
}

void AccountAck_OrderInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccountAck_OrderInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccountAck_OrderInfo_descriptor_;
}

const AccountAck_OrderInfo& AccountAck_OrderInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_toptrader_2eproto();
  return *default_instance_;
}

AccountAck_OrderInfo* AccountAck_OrderInfo::default_instance_ = NULL;

AccountAck_OrderInfo* AccountAck_OrderInfo::New() const {
  return new AccountAck_OrderInfo;
}

void AccountAck_OrderInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    orderid_ = 0u;
    if (has_code()) {
      if (code_ != &::google::protobuf::internal::kEmptyString) {
        code_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    buy_ = false;
    open_ = false;
    commissionslot_ = 0u;
    commissionprice_ = 0;
    settleslot_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    settleprice_ = 0;
    unsettleslot_ = 0u;
    if (has_commissiontime()) {
      if (commissiontime_ != &::google::protobuf::internal::kEmptyString) {
        commissiontime_->clear();
      }
    }
    if (has_declaretime()) {
      if (declaretime_ != &::google::protobuf::internal::kEmptyString) {
        declaretime_->clear();
      }
    }
    if (has_canceltime()) {
      if (canceltime_ != &::google::protobuf::internal::kEmptyString) {
        canceltime_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AccountAck_OrderInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 orderid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &orderid_)));
          set_has_orderid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_code;
        break;
      }

      // required string code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->code().data(), this->code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_status;
        break;
      }

      // required string status = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_buy;
        break;
      }

      // required bool buy = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &buy_)));
          set_has_buy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_open;
        break;
      }

      // required bool open = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_open:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &open_)));
          set_has_open();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_commissionslot;
        break;
      }

      // required uint32 commissionslot = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_commissionslot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &commissionslot_)));
          set_has_commissionslot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_commissionprice;
        break;
      }

      // required float commissionprice = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_commissionprice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &commissionprice_)));
          set_has_commissionprice();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_settleslot;
        break;
      }

      // required uint32 settleslot = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_settleslot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &settleslot_)));
          set_has_settleslot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_settleprice;
        break;
      }

      // required float settleprice = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_settleprice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &settleprice_)));
          set_has_settleprice();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_unsettleslot;
        break;
      }

      // required uint32 unsettleslot = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unsettleslot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unsettleslot_)));
          set_has_unsettleslot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_commissiontime;
        break;
      }

      // required string commissiontime = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_commissiontime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_commissiontime()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->commissiontime().data(), this->commissiontime().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_declaretime;
        break;
      }

      // required string declaretime = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_declaretime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_declaretime()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->declaretime().data(), this->declaretime().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_canceltime;
        break;
      }

      // required string canceltime = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_canceltime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_canceltime()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->canceltime().data(), this->canceltime().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccountAck_OrderInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 orderid = 1;
  if (has_orderid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->orderid(), output);
  }

  // required string code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->code().data(), this->code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->code(), output);
  }

  // required string status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->status(), output);
  }

  // required bool buy = 4;
  if (has_buy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->buy(), output);
  }

  // required bool open = 5;
  if (has_open()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->open(), output);
  }

  // required uint32 commissionslot = 6;
  if (has_commissionslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->commissionslot(), output);
  }

  // required float commissionprice = 7;
  if (has_commissionprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->commissionprice(), output);
  }

  // required uint32 settleslot = 8;
  if (has_settleslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->settleslot(), output);
  }

  // required float settleprice = 9;
  if (has_settleprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->settleprice(), output);
  }

  // required uint32 unsettleslot = 10;
  if (has_unsettleslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->unsettleslot(), output);
  }

  // required string commissiontime = 11;
  if (has_commissiontime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->commissiontime().data(), this->commissiontime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->commissiontime(), output);
  }

  // required string declaretime = 12;
  if (has_declaretime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->declaretime().data(), this->declaretime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->declaretime(), output);
  }

  // required string canceltime = 13;
  if (has_canceltime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->canceltime().data(), this->canceltime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->canceltime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AccountAck_OrderInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 orderid = 1;
  if (has_orderid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->orderid(), target);
  }

  // required string code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->code().data(), this->code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->code(), target);
  }

  // required string status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->status(), target);
  }

  // required bool buy = 4;
  if (has_buy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->buy(), target);
  }

  // required bool open = 5;
  if (has_open()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->open(), target);
  }

  // required uint32 commissionslot = 6;
  if (has_commissionslot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->commissionslot(), target);
  }

  // required float commissionprice = 7;
  if (has_commissionprice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->commissionprice(), target);
  }

  // required uint32 settleslot = 8;
  if (has_settleslot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->settleslot(), target);
  }

  // required float settleprice = 9;
  if (has_settleprice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->settleprice(), target);
  }

  // required uint32 unsettleslot = 10;
  if (has_unsettleslot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->unsettleslot(), target);
  }

  // required string commissiontime = 11;
  if (has_commissiontime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->commissiontime().data(), this->commissiontime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->commissiontime(), target);
  }

  // required string declaretime = 12;
  if (has_declaretime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->declaretime().data(), this->declaretime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->declaretime(), target);
  }

  // required string canceltime = 13;
  if (has_canceltime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->canceltime().data(), this->canceltime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->canceltime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AccountAck_OrderInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 orderid = 1;
    if (has_orderid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->orderid());
    }

    // required string code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->code());
    }

    // required string status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }

    // required bool buy = 4;
    if (has_buy()) {
      total_size += 1 + 1;
    }

    // required bool open = 5;
    if (has_open()) {
      total_size += 1 + 1;
    }

    // required uint32 commissionslot = 6;
    if (has_commissionslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->commissionslot());
    }

    // required float commissionprice = 7;
    if (has_commissionprice()) {
      total_size += 1 + 4;
    }

    // required uint32 settleslot = 8;
    if (has_settleslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->settleslot());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required float settleprice = 9;
    if (has_settleprice()) {
      total_size += 1 + 4;
    }

    // required uint32 unsettleslot = 10;
    if (has_unsettleslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unsettleslot());
    }

    // required string commissiontime = 11;
    if (has_commissiontime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->commissiontime());
    }

    // required string declaretime = 12;
    if (has_declaretime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->declaretime());
    }

    // required string canceltime = 13;
    if (has_canceltime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->canceltime());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccountAck_OrderInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AccountAck_OrderInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccountAck_OrderInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccountAck_OrderInfo::MergeFrom(const AccountAck_OrderInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_orderid()) {
      set_orderid(from.orderid());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_buy()) {
      set_buy(from.buy());
    }
    if (from.has_open()) {
      set_open(from.open());
    }
    if (from.has_commissionslot()) {
      set_commissionslot(from.commissionslot());
    }
    if (from.has_commissionprice()) {
      set_commissionprice(from.commissionprice());
    }
    if (from.has_settleslot()) {
      set_settleslot(from.settleslot());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_settleprice()) {
      set_settleprice(from.settleprice());
    }
    if (from.has_unsettleslot()) {
      set_unsettleslot(from.unsettleslot());
    }
    if (from.has_commissiontime()) {
      set_commissiontime(from.commissiontime());
    }
    if (from.has_declaretime()) {
      set_declaretime(from.declaretime());
    }
    if (from.has_canceltime()) {
      set_canceltime(from.canceltime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AccountAck_OrderInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccountAck_OrderInfo::CopyFrom(const AccountAck_OrderInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountAck_OrderInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00001fff) != 0x00001fff) return false;

  return true;
}

void AccountAck_OrderInfo::Swap(AccountAck_OrderInfo* other) {
  if (other != this) {
    std::swap(orderid_, other->orderid_);
    std::swap(code_, other->code_);
    std::swap(status_, other->status_);
    std::swap(buy_, other->buy_);
    std::swap(open_, other->open_);
    std::swap(commissionslot_, other->commissionslot_);
    std::swap(commissionprice_, other->commissionprice_);
    std::swap(settleslot_, other->settleslot_);
    std::swap(settleprice_, other->settleprice_);
    std::swap(unsettleslot_, other->unsettleslot_);
    std::swap(commissiontime_, other->commissiontime_);
    std::swap(declaretime_, other->declaretime_);
    std::swap(canceltime_, other->canceltime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AccountAck_OrderInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccountAck_OrderInfo_descriptor_;
  metadata.reflection = AccountAck_OrderInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AccountAck_PositionInfo::kCodeFieldNumber;
const int AccountAck_PositionInfo::kBuyslotFieldNumber;
const int AccountAck_PositionInfo::kBuypriceFieldNumber;
const int AccountAck_PositionInfo::kSellslotFieldNumber;
const int AccountAck_PositionInfo::kSellpriceFieldNumber;
const int AccountAck_PositionInfo::kTodaybuyslotFieldNumber;
const int AccountAck_PositionInfo::kTodaysellslotFieldNumber;
#endif  // !_MSC_VER

AccountAck_PositionInfo::AccountAck_PositionInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AccountAck_PositionInfo::InitAsDefaultInstance() {
}

AccountAck_PositionInfo::AccountAck_PositionInfo(const AccountAck_PositionInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AccountAck_PositionInfo::SharedCtor() {
  _cached_size_ = 0;
  code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyslot_ = 0u;
  buyprice_ = 0;
  sellslot_ = 0u;
  sellprice_ = 0;
  todaybuyslot_ = 0u;
  todaysellslot_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccountAck_PositionInfo::~AccountAck_PositionInfo() {
  SharedDtor();
}

void AccountAck_PositionInfo::SharedDtor() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (this != default_instance_) {
  }
}

void AccountAck_PositionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccountAck_PositionInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccountAck_PositionInfo_descriptor_;
}

const AccountAck_PositionInfo& AccountAck_PositionInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_toptrader_2eproto();
  return *default_instance_;
}

AccountAck_PositionInfo* AccountAck_PositionInfo::default_instance_ = NULL;

AccountAck_PositionInfo* AccountAck_PositionInfo::New() const {
  return new AccountAck_PositionInfo;
}

void AccountAck_PositionInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_code()) {
      if (code_ != &::google::protobuf::internal::kEmptyString) {
        code_->clear();
      }
    }
    buyslot_ = 0u;
    buyprice_ = 0;
    sellslot_ = 0u;
    sellprice_ = 0;
    todaybuyslot_ = 0u;
    todaysellslot_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AccountAck_PositionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->code().data(), this->code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_buyslot;
        break;
      }

      // required uint32 buyslot = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buyslot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buyslot_)));
          set_has_buyslot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_buyprice;
        break;
      }

      // required float buyprice = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_buyprice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &buyprice_)));
          set_has_buyprice();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sellslot;
        break;
      }

      // required uint32 sellslot = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sellslot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sellslot_)));
          set_has_sellslot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_sellprice;
        break;
      }

      // required float sellprice = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sellprice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sellprice_)));
          set_has_sellprice();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_todaybuyslot;
        break;
      }

      // required uint32 todaybuyslot = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_todaybuyslot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &todaybuyslot_)));
          set_has_todaybuyslot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_todaysellslot;
        break;
      }

      // required uint32 todaysellslot = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_todaysellslot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &todaysellslot_)));
          set_has_todaysellslot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccountAck_PositionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->code().data(), this->code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->code(), output);
  }

  // required uint32 buyslot = 2;
  if (has_buyslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->buyslot(), output);
  }

  // required float buyprice = 3;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->buyprice(), output);
  }

  // required uint32 sellslot = 4;
  if (has_sellslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->sellslot(), output);
  }

  // required float sellprice = 5;
  if (has_sellprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->sellprice(), output);
  }

  // required uint32 todaybuyslot = 6;
  if (has_todaybuyslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->todaybuyslot(), output);
  }

  // required uint32 todaysellslot = 7;
  if (has_todaysellslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->todaysellslot(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AccountAck_PositionInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->code().data(), this->code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->code(), target);
  }

  // required uint32 buyslot = 2;
  if (has_buyslot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->buyslot(), target);
  }

  // required float buyprice = 3;
  if (has_buyprice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->buyprice(), target);
  }

  // required uint32 sellslot = 4;
  if (has_sellslot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->sellslot(), target);
  }

  // required float sellprice = 5;
  if (has_sellprice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->sellprice(), target);
  }

  // required uint32 todaybuyslot = 6;
  if (has_todaybuyslot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->todaybuyslot(), target);
  }

  // required uint32 todaysellslot = 7;
  if (has_todaysellslot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->todaysellslot(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AccountAck_PositionInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->code());
    }

    // required uint32 buyslot = 2;
    if (has_buyslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buyslot());
    }

    // required float buyprice = 3;
    if (has_buyprice()) {
      total_size += 1 + 4;
    }

    // required uint32 sellslot = 4;
    if (has_sellslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sellslot());
    }

    // required float sellprice = 5;
    if (has_sellprice()) {
      total_size += 1 + 4;
    }

    // required uint32 todaybuyslot = 6;
    if (has_todaybuyslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->todaybuyslot());
    }

    // required uint32 todaysellslot = 7;
    if (has_todaysellslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->todaysellslot());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccountAck_PositionInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AccountAck_PositionInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccountAck_PositionInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccountAck_PositionInfo::MergeFrom(const AccountAck_PositionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_buyslot()) {
      set_buyslot(from.buyslot());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_sellslot()) {
      set_sellslot(from.sellslot());
    }
    if (from.has_sellprice()) {
      set_sellprice(from.sellprice());
    }
    if (from.has_todaybuyslot()) {
      set_todaybuyslot(from.todaybuyslot());
    }
    if (from.has_todaysellslot()) {
      set_todaysellslot(from.todaysellslot());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AccountAck_PositionInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccountAck_PositionInfo::CopyFrom(const AccountAck_PositionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountAck_PositionInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void AccountAck_PositionInfo::Swap(AccountAck_PositionInfo* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(buyslot_, other->buyslot_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(sellslot_, other->sellslot_);
    std::swap(sellprice_, other->sellprice_);
    std::swap(todaybuyslot_, other->todaybuyslot_);
    std::swap(todaysellslot_, other->todaysellslot_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AccountAck_PositionInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccountAck_PositionInfo_descriptor_;
  metadata.reflection = AccountAck_PositionInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AccountAck::kAccinfoFieldNumber;
const int AccountAck::kOrderinfoFieldNumber;
const int AccountAck::kPositioninfoFieldNumber;
#endif  // !_MSC_VER

AccountAck::AccountAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AccountAck::InitAsDefaultInstance() {
  accinfo_ = const_cast< ::toptraer::oscar::AccountAck_AccountInfo*>(&::toptraer::oscar::AccountAck_AccountInfo::default_instance());
}

AccountAck::AccountAck(const AccountAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AccountAck::SharedCtor() {
  _cached_size_ = 0;
  accinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccountAck::~AccountAck() {
  SharedDtor();
}

void AccountAck::SharedDtor() {
  if (this != default_instance_) {
    delete accinfo_;
  }
}

void AccountAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccountAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccountAck_descriptor_;
}

const AccountAck& AccountAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_toptrader_2eproto();
  return *default_instance_;
}

AccountAck* AccountAck::default_instance_ = NULL;

AccountAck* AccountAck::New() const {
  return new AccountAck;
}

void AccountAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_accinfo()) {
      if (accinfo_ != NULL) accinfo_->::toptraer::oscar::AccountAck_AccountInfo::Clear();
    }
  }
  orderinfo_.Clear();
  positioninfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AccountAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .toptraer.oscar.AccountAck.AccountInfo accinfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_accinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_orderinfo;
        break;
      }

      // repeated .toptraer.oscar.AccountAck.OrderInfo orderinfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_orderinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_orderinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_orderinfo;
        if (input->ExpectTag(26)) goto parse_positioninfo;
        break;
      }

      // repeated .toptraer.oscar.AccountAck.PositionInfo positioninfo = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_positioninfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_positioninfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_positioninfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccountAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .toptraer.oscar.AccountAck.AccountInfo accinfo = 1;
  if (has_accinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->accinfo(), output);
  }

  // repeated .toptraer.oscar.AccountAck.OrderInfo orderinfo = 2;
  for (int i = 0; i < this->orderinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->orderinfo(i), output);
  }

  // repeated .toptraer.oscar.AccountAck.PositionInfo positioninfo = 3;
  for (int i = 0; i < this->positioninfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->positioninfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AccountAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .toptraer.oscar.AccountAck.AccountInfo accinfo = 1;
  if (has_accinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->accinfo(), target);
  }

  // repeated .toptraer.oscar.AccountAck.OrderInfo orderinfo = 2;
  for (int i = 0; i < this->orderinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->orderinfo(i), target);
  }

  // repeated .toptraer.oscar.AccountAck.PositionInfo positioninfo = 3;
  for (int i = 0; i < this->positioninfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->positioninfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AccountAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .toptraer.oscar.AccountAck.AccountInfo accinfo = 1;
    if (has_accinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->accinfo());
    }

  }
  // repeated .toptraer.oscar.AccountAck.OrderInfo orderinfo = 2;
  total_size += 1 * this->orderinfo_size();
  for (int i = 0; i < this->orderinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->orderinfo(i));
  }

  // repeated .toptraer.oscar.AccountAck.PositionInfo positioninfo = 3;
  total_size += 1 * this->positioninfo_size();
  for (int i = 0; i < this->positioninfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->positioninfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccountAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AccountAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccountAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccountAck::MergeFrom(const AccountAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  orderinfo_.MergeFrom(from.orderinfo_);
  positioninfo_.MergeFrom(from.positioninfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accinfo()) {
      mutable_accinfo()->::toptraer::oscar::AccountAck_AccountInfo::MergeFrom(from.accinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AccountAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccountAck::CopyFrom(const AccountAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_accinfo()) {
    if (!this->accinfo().IsInitialized()) return false;
  }
  for (int i = 0; i < orderinfo_size(); i++) {
    if (!this->orderinfo(i).IsInitialized()) return false;
  }
  for (int i = 0; i < positioninfo_size(); i++) {
    if (!this->positioninfo(i).IsInitialized()) return false;
  }
  return true;
}

void AccountAck::Swap(AccountAck* other) {
  if (other != this) {
    std::swap(accinfo_, other->accinfo_);
    orderinfo_.Swap(&other->orderinfo_);
    positioninfo_.Swap(&other->positioninfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AccountAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccountAck_descriptor_;
  metadata.reflection = AccountAck_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace oscar
}  // namespace toptraer

// @@protoc_insertion_point(global_scope)
